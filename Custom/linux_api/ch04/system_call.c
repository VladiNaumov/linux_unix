/* 4. File I/O: The Universal I/O */

#include <sys/stat.h>
#include <fcntl.h>

/* Системный вызов open() либо открывает существующий файл, либо создает и открывает новый файл. */
int open(const char *pathname, int flags, ... /* mode_t mode */);
// Возвращает файловый дескриптор при успешном выполнении или -1 при ошибке

/*
    В ранних реализациях UNIX open() имел только два аргумента и не мог создавать
    новый файл. Для создания и открытия нового файла использовался системный вызов creat().
*/
int creat(const char *pathname, mode_t mode);
// Возвращает файловый дескриптор или -1 при ошибке

/* Системный вызов read() читает данные из открытого файла, на который указывает дескриптор fd. */
ssize_t read(int fd, void *buffer, size_t count);
// Возвращает количество прочитанных байтов, 0 при достижении конца файла или -1 при ошибке

/* Системный вызов write() записывает данные в открытый файл. */
ssize_t write(int fd, void *buffer, size_t count);
// Возвращает количество записанных байтов или -1 при ошибке

/*
    Системный вызов close() закрывает открытый файловый дескриптор, освобождая его
    для повторного использования процессом. Когда процесс завершается, все его открытые
    файловые дескрипторы автоматически закрываются.
*/
int close(int fd);
// Возвращает 0 при успешном выполнении или -1 при ошибке

/*
    Для каждого открытого файла ядро записывает смещение файла, иногда также называемое
    указателем на чтение/запись. Это позиция в файле, с которой начнется следующая
    операция read() или write().
*/
off_t lseek(int fd, off_t offset, int whence);
// Возвращает новое смещение файла при успехе или -1 при ошибке

/*
    Системный вызов ioctl() — это универсальный механизм для выполнения операций с файлами и
    устройствами, которые не укладываются в общую модель ввода-вывода.
*/
int ioctl(int fd, int request, ... /* argp */);
// Возвращаемое значение при успешном выполнении зависит от запроса или -1 при ошибке

/* Системный вызов fcntl() выполняет ряд управляющих операций над открытым файловым дескриптором. */
#include <fcntl.h>
int fcntl(int fd, int cmd, ...);
// Возвращаемое значение при успехе зависит от cmd или -1 при ошибке

/*
    Вызов dup() принимает старый дескриптор файла oldfd и возвращает новый дескриптор,
    который ссылается на то же открытое описание файла. Новый дескриптор гарантированно
    будет наименьшим неиспользуемым дескриптором файла.
*/
#include <unistd.h>
int dup(int oldfd);
int dup2(int oldfd, int newfd);
int dup3(int oldfd, int newfd, int flags);
// Возвращает (новый) файловый дескриптор при успехе или -1 при ошибке

/*
    Системные вызовы pread() и pwrite() работают аналогично read() и write(),
    за исключением того, что ввод-вывод выполняется в позиции offset, а не в текущем смещении файла.
*/
#include <unistd.h>
ssize_t pread(int fd, void *buf, size_t count, off_t offset);
// Возвращает количество прочитанных байтов, 0 при EOF или -1 при ошибке
ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);
// Возвращает количество записанных байтов или -1 при ошибке

/* Системные вызовы readv() и writev() выполняют scatter-gather ввод-вывод. */
#include <sys/uio.h>
ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
// Возвращает количество прочитанных байтов, 0 при EOF или -1 при ошибке
ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
// Возвращает количество записанных байтов или -1 при ошибке

/* Системные вызовы truncate() и ftruncate() устанавливают размер файла в значение, указанное length. */
#include <unistd.h>
int truncate(const char *pathname, off_t length);
int ftruncate(int fd, off_t length);
// Оба возвращают 0 при успехе или -1 при ошибке

/* Функция mkstemp() генерирует уникальное имя файла на основе шаблона, указанного вызвавшим процессом, и открывает файл, возвращая файловый дескриптор. */
#include <stdlib.h>
int mkstemp(char *template);
// Возвращает файловый дескриптор при успехе или -1 при ошибке

/* Функция tmpfile() создает временный файл с уникальным именем, открытый для чтения и записи. */
#include <stdio.h>
FILE *tmpfile(void);
// Возвращает указатель на файл при успехе или NULL при ошибке

/*Важные дополнения:
- dup и dup2: Дублирование дескрипторов позволяет направлять вывод одного файла в другой, что может быть полезно для перенаправления ввода/вывода.
- pread и pwrite: Независимо от текущего смещения, указание конкретной позиции в файле позволяет работать с данными в произвольной позиции, что может быть полезно для записи логов и работы с базами данных.*/