/*
    Эта программа демонстрирует использование системного вызова readv(),
    который позволяет считывать данные сразу в несколько буферов за один вызов.
 *
 */

#include <fcntl.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include "../lib/tlpi_hdr.h"

int main(int ac, char *av[])
{
    int fd;
    struct iovec iov[3];   // Массив структур iovec для хранения информации о буферах

    struct stat myStruct;   // Первый буфер, структура для хранения информации о файле
    int x;                  // Второй буфер, переменная для хранения целого числа
#define STR_SIZE 100
    char str[STR_SIZE];     // Третий буфер, строка для хранения текстовых данных

    ssize_t numRead, totRequired;  // Переменные для отслеживания прочитанных байт и общего объема данных

    if (ac != 2) {  // Проверяем количество аргументов командной строки (ожидается имя файла)
        usageErr("%s file\n", av[0]);
    }

    // Открываем файл на чтение
    fd = open(av[1], O_RDONLY);
    if (fd == -1) {
        errExit("open");
    }

    totRequired = 0;  // Счётчик общего количества байт, которые нужно прочитать

    // Настраиваем первый буфер для чтения информации о файле
    iov[0].iov_base = &myStruct;   // Базовый адрес для первого буфера
    iov[0].iov_len = sizeof(struct stat);   // Длина первого буфера (размер структуры stat)
    totRequired += iov[0].iov_len;  // Увеличиваем общее количество запрашиваемых байт

    // Настраиваем второй буфер для чтения целого числа
    iov[1].iov_base = &x;   // Базовый адрес для второго буфера
    iov[1].iov_len = sizeof(x);   // Длина второго буфера (размер переменной int)
    totRequired += iov[1].iov_len;  // Увеличиваем общее количество запрашиваемых байт

    // Настраиваем третий буфер для чтения строки
    iov[2].iov_base = str;   // Базовый адрес для третьего буфера
    iov[2].iov_len = STR_SIZE;  // Длина третьего буфера (100 символов)
    totRequired += iov[2].iov_len;  // Увеличиваем общее количество запрашиваемых байт

    // Читаем данные с помощью readv (все буферы заполняются за один системный вызов)
    numRead = readv(fd, iov, 3);
    if (numRead == -1) {
        errExit("readv");
    }

    // Если было прочитано меньше байт, чем запрашивалось
    if (numRead < totRequired) {
        printf("read fewer bytes than requested\n");
    }

    // Выводим информацию о том, сколько байт запросили и сколько реально прочитали
    printf("total bytes requested: %ld; bytes read: %ld\n",
           (long)totRequired, (long)numRead);

    exit(EXIT_SUCCESS);
}

/*
 * Ключевые моменты:
Использование iovec: Структура iovec используется для хранения информации о каждом буфере. Она содержит указатель на начало буфера (iov_base) и его длину (iov_len).
Системный вызов readv(): Этот вызов позволяет прочитать данные из файла сразу в несколько буферов.

 В данном примере данные считываются в:

- Структуру struct stat
- Переменную int
- Строку размером 100 байт
- Агрегация данных: Мы используем несколько буферов для чтения разных типов данных (структура, целое число, строка) за один вызов readv(). Это позволяет эффективно выполнять ввод/вывод, не разбивая его на несколько операций read().

Обработка ошибок: Если количество прочитанных байт меньше запрашиваемого, выводится сообщение об этом. Программа обрабатывает ошибки при открытии файла и вызове readv().

Вывод результата: Программа выводит, сколько байт было запрошено и сколько реально прочитано из файла.

Этот пример демонстрирует, как можно использовать векторный ввод/вывод для оптимизации операций чтения с файлов или других источников данных.*/