/*
 * seek_io.c: программа для демонстрации использования `lseek(2)`
 *
 * usage: seek_io file {options}
 *
 * options:
 * 	soffset: переместить указатель файла на смещение в байтах от начала файла
 * 	rlength: прочитать length байт из файла, начиная с текущего смещения,
 * 		и отобразить их в текстовой форме
 * 	Rlength: прочитать length байт из файла, начиная с текущего смещения,
 * 		и отобразить их в шестнадцатеричном формате
 * 	wstr: записать строку символов, указанную в str, с текущего смещения файла
 *
 * compile: gcc seek_io.c ../lib/get_num.c ../lib/error_functions.c -o seek_io
*/

#include <sys/stat.h>
#include <fcntl.h>
#include <ctype.h>
#include "../lib/tlpi_hdr.h"  // Подключаем заголовочные файлы с функциями обработки ошибок и функцией для получения чисел

int main(int ac, char *av[])
{
    size_t len;  // Переменная для хранения длины данных, которые нужно прочитать
    off_t offset;  // Переменная для хранения смещения указателя файла
    int fd, ap, j;  // fd — файловый дескриптор, ap — индекс аргументов, j — индекс для цикла
    char *buf = NULL;  // Буфер для хранения прочитанных данных
    ssize_t numRead, numWritten;  // Переменные для хранения количества прочитанных и записанных байт

    // Проверка количества аргументов. Программа должна иметь хотя бы 3 аргумента: имя файла и как минимум одну операцию.
    if (ac < 3 || strcmp(av[1], "--help") == 0) {
        // Если аргументов недостаточно или пользователь ввел --help, выводим справку по использованию программы
        usageErr(
                "%s file {r<length>|R<length>|w<string>|s<offset>}...\n",
                av[0]);  // av[0] — имя программы
    }

    // Открываем файл для чтения и записи. Если файл не существует, создаем его с правами 0666 (чтение/запись для всех).
    fd = open(av[1], O_RDWR | O_CREAT, 0666);
    if (fd == -1) {  // Проверяем, удалось ли открыть файл
        errExit("open");  // В случае ошибки завершаем программу с сообщением об ошибке
    }

    // Проходим по всем переданным операциям (аргументам, начиная со второго)
    for (ap = 2; ap < ac; ap++) {
        switch (av[ap][0]) {
            // Чтение данных в текстовом ('r') или шестнадцатеричном ('R') формате
            case 'r':  // 'r' — вывести байты в текстовом виде
            case 'R':  // 'R' — вывести байты в шестнадцатеричном виде
                len = getLong(&av[ap][1], GN_ANY_BASE, av[ap]);  // Получаем длину данных для чтения из аргумента
                buf = malloc(len);  // Выделяем память под буфер для чтения
                if (buf == NULL) {  // Проверяем, успешно ли выделена память
                    errExit("malloc");
                }
                numRead = read(fd, buf, len);  // Читаем из файла в буфер указанное количество байт
                if (numRead == -1) {  // Проверяем наличие ошибки при чтении
                    errExit("read");
                }
                if (numRead == 0) {  // Если достигнут конец файла
                    printf("%s: end-of-file\n", av[ap]);  // Сообщаем об этом
                } else {
                    printf("%s: ", av[ap]);  // Выводим информацию о выполненной операции
                    for (j = 0; j < numRead; j++) {  // Проходим по всем прочитанным байтам
                        if (av[ap][0] == 'r') {  // Если операция 'r', выводим байты в текстовом виде
                            printf("%c ",
                                   isprint((unsigned char)
                                                   buf[j]) ?
                                   buf[j] :  // Печатаем символ, если он отображаемый
                                   '?');  // Если символ не отображаемый, выводим '?'
                        } else {  // Если операция 'R', выводим байты в шестнадцатеричном виде
                            printf("%02x ", (unsigned int)buf[j]);
                        }
                    }
                    printf("\n");  // Завершаем вывод
                }
                free(buf);  // Освобождаем память, выделенную под буфер
                buf = NULL;  // Обнуляем указатель на буфер
                break;

                // Запись строки в файл с текущего смещения
            case 'w':  // 'w' — записать строку в файл
                // Записываем строку, начиная с позиции после символа 'w' в аргументе
                numWritten = write(fd, &av[ap][1], strlen(&av[ap][1]));
                if (numWritten == -1) {  // Проверяем наличие ошибки при записи
                    errExit("write");
                }
                // Сообщаем пользователю, сколько байт было записано
                printf("%s: wrote %ld bytes\n", av[ap], (long)numWritten);
                break;

                // Перемещение указателя файла на новое смещение
            case 's':  // 's' — переместить указатель на заданное смещение
                offset = getLong(&av[ap][1], GN_ANY_BASE, av[ap]);  // Получаем смещение из аргумента
                // Выполняем сдвиг указателя файла на указанное количество байт относительно текущего положения
                if (lseek(fd, offset, SEEK_CUR) == -1) {  // Проверяем наличие ошибки при перемещении
                    errExit("lseek");
                }
                // Сообщаем, что перемещение указателя файла прошло успешно
                printf("%s: seek succeeded\n", av[ap]);
                break;

            default:  // Если аргумент не начинается с 'r', 'R', 'w' или 's'
                cmdLineErr("Argument must start with [rRws]: %s\n", av[ap]);  // Выводим ошибку неправильного аргумента
        }
    }

    exit(EXIT_SUCCESS);  // Успешно завершаем программу
}


/*
 * Программа демонстрирует использование системного вызова `lseek()` для работы с файловыми смещениями, а также чтение и запись данных в файл. Вот основные моменты программы:

1. **Аргументы программы**:
   - `r<length>` — чтение `length` байт из текущего смещения файла и вывод данных в текстовой форме.
   - `R<length>` — чтение `length` байт и вывод в шестнадцатеричном формате.
   - `w<string>` — запись строки `string` в файл с текущего смещения.
   - `s<offset>` — сдвиг указателя файла на `offset` байт относительно текущего положения.

2. **Открытие файла**:
   - Программа открывает файл для чтения и записи с флагами `O_RDWR | O_CREAT`, что позволяет читать и писать, а также создавать файл, если его не существует. Права доступа задаются как `0666` (чтение и запись для всех).

3. **Чтение данных**:
   - В зависимости от аргумента (`r` или `R`), программа либо читает данные и выводит их в виде текста, либо в шестнадцатеричном формате.

4. **Запись данных**:
   - Аргумент `w<string>` записывает строку `string` в файл с текущего смещения.

5. **Перемещение указателя файла**:
   - Аргумент `s<offset>` перемещает указатель файла на указанное смещение.

6. **Обработка ошибок**:
   - Программа проверяет корректность аргументов, а также ошибки при работе с файлами, такими как ошибки при открытии, чтении, записи и перемещении указателя.

Это базовая утилита для работы с файлами, которая показывает, как перемещаться по файлу и манипулировать его содержимым.
 * */